/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>
#include "main.h"
#include "my_led.h"


#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif





__attribute__((naked)) void set_sp_to_psp();
__attribute__((naked)) void init_schd_task(uint32_t schd_stack_start);
void init_systick_tim(uint32_t tm);
void init_stack_tasks(void);
void processor_fault_enable();
void task1();
void task2();
void task3();
void task4();
void save_psp_current_value(uint32_t curr_psp);
void update_the_next_task();
uint32_t get_psp_current_value();


uint32_t task_psp_holder [MAX_TASKS] = {T1_STACK_START, T2_STACK_START, T3_STACK_START, T4_STACK_START};

uint32_t task_handler_holder [MAX_TASKS];


//A global variable that tracks the current task
uint8_t current_task = 0; // It's initialized with task one first.


int main(void)
{
	//Enable Some processor fault exceptions mem, bus and usage.
	processor_fault_enable();

	//Do this before calling the function init_stack_tasks function
	init_schd_task(SCHED_STACK_START);

	task_handler_holder[0] = (uintptr_t)task1;
	task_handler_holder[1] = (uintptr_t)task2;
	task_handler_holder[2] = (uintptr_t)task3;
	task_handler_holder[3] = (uintptr_t)task4;


	init_stack_tasks();
	led_init();

	init_systick_tim(TICK_HZ);

	set_sp_to_psp();

	task1();


    /* Loop forever */
	for(;;);
}

void task1(){
	while(1){
		//Turn green LED ON and OFF
		led_on(LT_GREEN);
		delay(DELAY_COUNT_1MS);
		led_off(LT_GREEN);
		delay(DELAY_COUNT_1S);
	}
}

void task2(){
	while(1){
		//Turn green LED ON and OFF
		led_on(LT_RED);
		delay(DELAY_COUNT_125MS);
		led_off(LT_RED);
		delay(DELAY_COUNT_1S);
	}
}


void task3(){
	while(1){
		led_on(LT_RED);
		delay(DELAY_COUNT_1S);
		led_off(LT_RED);
		delay(DELAY_COUNT_250MS);
	}
}


void task4(){
	while(1){
		led_on(LT_GREEN);
		delay(DELAY_COUNT_250MS);
		led_off(LT_GREEN);
		delay(DELAY_COUNT_1MS);
	}
}



void init_systick_tim(uint32_t tick_hz){

	uint32_t *pSRVR = (uint32_t*)0xE000E014;      //SYSTICK reload value register.
	uint32_t count_value = (SYSTICK_TIM_CLK /tick_hz) - 1; //This should give 1600 to achieve a 1mSec per tick


	*pSRVR &= ~(0x00FFFFFF); //clear the value of the SVR


	*pSRVR |= count_value; //Load the count value into the SVR

	/*Go to the the SYST_CSR register and configure the following (SYSTICK Control and Status register.):
	 * Enable the Counter by setting the (ENABLE) bit field [0] of the register to 1.
	 * Enable the systick to trigger an exception when count down is 0 by setting the second bit field (TICKINT)[1] to 1.
	 * Select the internal clock source to be internal by setting the second bit field (TICKINT)[1] to 1.
	 */

	uint32_t *pSCSR = (uint32_t*)0xE000E010;

	//Clear the first three bit fields.
	*pSCSR &= ~(0x00000007);

	*pSCSR |= (1 << 1); //Enables the systick exception request at 0 countdown.
	*pSCSR |= (1 << 2); //Enables the systick clock source as internal.

	*pSCSR |= (1 << 0); //Enables the systick timer.


}


/*
 * Since we will be changing the value of MSP (processor register), we will need to do this via gcc inline assembly code. Hence,
 * we will make this function naked.
 * In STM32 development, particularly when using ARM Cortex-M microcontrollers,
 * a naked function is a function declared with the __attribute__((naked)) attribute.
 * This attribute instructs the compiler to omit the standard prologue and epilogue code
 * that it typically generates for function entry and exit.
 * As a result, the function contains no automatic stack frame setup or teardown,
 * providing the developer with complete control over the function's assembly code.
 */
__attribute__((naked)) void init_schd_task(uint32_t schd_stack_start){

	//set the address of the MSP to the scheduler stack start address.
	__asm volatile ("MSR MSP, %0": : "r" (schd_stack_start) : );

	//Since this is a naked function and there are no prologue and epilogue code, we need to safely exit the function
	__asm volatile ("BX LR"); //Let's return from function call

}


/*
 * Let's initialise the stack of the tasks: T1_STACK_START, T2_STACK_START, T3_STACK_START, T4_STACK_START
 *
 */
void init_stack_tasks(void)
{

	uint32_t *pPSP;

	for(int i=0;i<MAX_TASKS;i++)
	{
		//Init the first address of the task.
		pPSP = (uint32_t*)task_psp_holder[i];

		//decrement and initialize the xPSR
		pPSP--;
		*pPSP=DUMMY_XPSR;

		//decrement and initialize the PC
		pPSP--;
		*pPSP=task_handler_holder[i];

		//decrement and initialize the LR register
		pPSP--; //store address of function as PC
		*pPSP=0xFFFFFFFD;


		for(int j=0;j < 13; j++) //R0 - R12
		{
			pPSP--;
			*pPSP = 0;
		}
		task_psp_holder[i] = (uint32_t)pPSP;
	}


}


void processor_fault_enable(){
	uint32_t *pSHCSR = (uint32_t*)0xE000ED24;

	//Memory fault enable
	*pSHCSR |= (1 << 16);

	//Bus fault enable
	*pSHCSR |= (1 << 17);

	//Usage fault enable
	*pSHCSR |= (1 << 18);

}

uint32_t get_psp_current_value(){

	return task_psp_holder[current_task];
}

__attribute__((naked)) void set_sp_to_psp(){

	//Get the current PSP first
	__asm volatile ("PUSH {LR}"); //So as not to correct the correct return address to main after the BL instruction, lets secure the main link address first
	__asm volatile ("BL get_psp_current_value"); //Let's call function get_psp_current_value. The returned PSP value would be returned to the R0 register of the processor.
	__asm volatile ("MSR PSP, R0"); //
	__asm volatile ("POP {LR}"); //Let's retrieve the initially pushed main LR value/address.


	//Goto to the control register and set the second bit field [1], (SPSEL) as 1 in order to change SP to PSP.

	__asm volatile ("MOV R0, #0x02"); //mov the value 0x02 to the R0 register.
	__asm volatile ("MSR CONTROL, R0"); //set the CONTROL register with the value of R0
	__asm volatile ("BX LR");

}


void save_psp_current_value(uint32_t curr_psp){

	task_psp_holder[current_task] = curr_psp;
}

void update_the_next_task(){

	current_task++;
	current_task %= MAX_TASKS; //Round robin fashion.
}

__attribute__((naked)) void SysTick_Handler(){

	/*Save context of current running task.*/

	//1. get current running task's SP value.
	__asm volatile ("MRS R0, PSP");
	//2. Use the retrieved PSP value and retrieve the stack frame(R4 - R11).
	__asm volatile ("STMDB R0!, {R4-R11}"); //Safely save these registers.
	//3. Save the current value of the PSP.
	__asm volatile ("PUSH {LR}"); //Save LR value first
	__asm volatile ("BL save_psp_current_value");  //This calls the function, and passes R0 as argument.


	/*Retrieve the context of the next task.*/
	//1. Decide next task to run.
	__asm volatile ("BL update_the_next_task");
	//2. Gets its past PSP value.
	__asm volatile ("BL get_psp_current_value");
	//3. Using that PSP value retrieve the stack frame(R4 - R11).
	__asm volatile ("LDMIA R0!, {R4-R11}"); //Loads and stores multiple registers (R4 - R11) incrementally
	//4. Update PSP and exit
	__asm volatile ("MSR PSP, R0"); //This PSP is pointing to the stack area of the next task to run.
	__asm volatile ("POP {LR}");

	__asm volatile ("BX LR"); //Safely exit

}

void MemManage_Handler(){
//	printf("Mem fault detected!! ");
	while(1);

}

void BusFault_Handler(){
//	printf("Bus fault detected!! ");
	while(1);

}

void UsageFault_Handler(){
//	printf("Mem fault detected!! ");
	while(1);
}





